<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="PHPCMS漏洞分析合集"><meta name="keywords" content="PHPCMS"><meta name="author" content="Mochazz"><meta name="copyright" content="Mochazz"><title>PHPCMS漏洞分析合集 | Mochazz's blog</title><link rel="shortcut icon" href="/favicon.png"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#v9-6-0任意文件上传"><span class="toc-number">1.</span> <span class="toc-text">v9.6.0任意文件上传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v9-6-0SQL注入"><span class="toc-number">2.</span> <span class="toc-text">v9.6.0SQL注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v9-6-1任意文件读取"><span class="toc-number">3.</span> <span class="toc-text">v9.6.1任意文件读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v9-6-2前台SQL注入"><span class="toc-number">4.</span> <span class="toc-text">v9.6.2前台SQL注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结束语"><span class="toc-number">5.</span> <span class="toc-text">结束语</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Mochazz</div><div class="author-info__description text-center">人若无名，方可潜心练剑</div><div class="follow-button"><a href="https://github.com/Mochazz">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">228</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">90</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">20</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://www.lmxspace.com">l1nk3r</a><a class="author-info-links__name text-center" href="https://www.virzz.com">Virink</a><a class="author-info-links__name text-center" href="https://www.kingkk.com">kingkk</a><a class="author-info-links__name text-center" href="https://hpdoger.cn">hpdoger</a><a class="author-info-links__name text-center" href="https://www.smi1e.top">smi1e</a><a class="author-info-links__name text-center" href="http://m4p1e.com">maple</a><a class="author-info-links__name text-center" href="https://zhzhdoai.github.io">osword</a><a class="author-info-links__name text-center" href="https://nikoeurus.github.io">Somnus</a><a class="author-info-links__name text-center" href="https://landgrey.me">LandGrey</a><a class="author-info-links__name text-center" href="https://www.cnpanda.net">panda</a><a class="author-info-links__name text-center" href="http://foreversong.cn">ADog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/backgroud.jpeg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Mochazz's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a><a class="site-page" href="/read">Read</a></span></div><div id="post-info"><div id="post-title">PHPCMS漏洞分析合集</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-18</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/代码审计/">代码审计</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本篇详细分析了 <strong>PHPCMS</strong> 的部分历史漏洞。其中多是以获取到漏洞点为场景，反向挖掘至漏洞触发入口（假设自己发现了漏洞点，模拟如何找寻整个攻击链及其入口点），旨在提高自身代码审计能力。当中包含一些网络上未公开的触发点，以及补丁对比分析与绕过。<a id="more"></a></p>
<h2 id="v9-6-0任意文件上传"><a href="#v9-6-0任意文件上传" class="headerlink" title="v9.6.0任意文件上传"></a>v9.6.0任意文件上传</h2><p>这个漏洞存在于用户注册处。这里有一个可控变量 <strong>$_POST[‘info’]</strong> 传入了 <strong>member_input</strong> 类的 <strong>get</strong> 方法中，跟进该方法。(下图对应文件位置：phpcms/modules/member/index.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/1.png" alt="1"></p>
<p>在 <strong>get</strong> 方法中，我们发现 <strong>$data</strong> 变量来自 <strong>$_POST[‘info’]</strong> ，并且我们可以调用 <strong>member_input</strong> 类的所有方法（对应下图 <strong>第47-48行</strong> 代码）。(下图对应文件位置：caches/caches_model/caches_data/member_input.class.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/2.png" alt="2"></p>
<p>看了一下 <strong>member_input</strong> 类的所有方法，只有一个 <strong>editor</strong> 方法比较好利用，而本次漏洞正是利用到这个方法。在这个方法中，调用了 <strong>attachment</strong> 类的 <strong>download</strong> 方法。(下图对应文件位置：caches/caches_model/caches_data/member_input.class.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/3.png" alt="3"></p>
<p>在 <strong>download</strong> 方法中，程序先使用正则对图片 <strong>URL</strong> 进行匹配，其中 <strong>$ext</strong> 只允许为<strong>gif|jpg|jpeg|bmp|png</strong> ，而我们使用 <strong><a href="http://xxxx/1.php?a.jpg" target="_blank" rel="noopener">http://xxxx/1.php?a.jpg</a></strong> 或者  <strong><a href="http://xxxx/1.php#a.jpg" target="_blank" rel="noopener">http://xxxx/1.php#a.jpg</a></strong> 即可绕过正则。(下图对应文件位置：phpcms/libs/classes/attachment.class.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/4.png" alt="4"></p>
<p>接着又使用 <strong>fillurl</strong> 方法对匹配到的远程图片地址进行处理，其实就是将 <strong>#</strong> 号之后的字符全部去除，例如 <strong><a href="http://xxxx/1.php#a.jpg" target="_blank" rel="noopener">http://xxxx/1.php#a.jpg</a></strong> 会被处理成  <strong><a href="http://xxxx/1.php" target="_blank" rel="noopener">http://xxxx/1.php</a></strong> 。(下图对应文件位置：phpcms/libs/classes/attachment.class.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/5.png" alt="5"></p>
<p> <strong>fillurl</strong> 方法处理后，又回到了 <strong>download</strong> 方法。程序直接调用 <strong>copy</strong> 函数将远程文件复制到本地（对应下图 <strong>161</strong> 行代码），远程文件名可预测，后缀名为上边处理后的 <strong>URL</strong> 文件名后缀，即 <strong>php</strong> ，最终导致 <strong>getshell</strong> 。其中 <strong>webshell</strong> 地址为 <strong><a href="http://website/uploadfile/date(&#39;Y/md/&#39;)/date(&#39;Ymdhis&#39;).rand" target="_blank" rel="noopener">http://website/uploadfile/date(&#39;Y/md/&#39;)/date(&#39;Ymdhis&#39;).rand</a>(100, 999).’.’.$fileext</strong> 。(下图对应文件位置：phpcms/libs/classes/attachment.class.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/6.png" alt="6"></p>
<p>最后我们再来看一下在官方发布的 <strong>PHPCMS v9.6.1</strong> 中是如何修复这个漏洞的，代码具体如下。可以明确看到，在官方补丁中，对 <strong>fileext($file)</strong> 获取到的文件后缀进行了黑名单校验。虽然暂时不能直接上传 <strong>shell</strong> ，但是还是可以上传图片马。如果 <strong>CMS</strong> 存在任意文件包含或任意文件名修改的漏洞，同样还是可以 <strong>getshell</strong> ，这里最好再对远程图片的内容进行校验下比较好。(下图对应文件位置：phpcms/libs/classes/attachment.class.php，左半图为PHPCMSv9.6.0，右半图为PHPCMSv9.6.1)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/7.png" alt="7"></p>
<p>实际上，单这个补丁中的正则来说，是可以绕过的，例如： <strong>.php%7f</strong> ，Windows下会将非法字符替换成空，但是其实后续还有一系列的问题，导致我没绕过。本以为要挖到0day了，我傻乐了半天：)</p>
<h2 id="v9-6-0SQL注入"><a href="#v9-6-0SQL注入" class="headerlink" title="v9.6.0SQL注入"></a>v9.6.0SQL注入</h2><p>这个版本的 <strong>SQL注入</strong> 主要在于程序对解密后的数据没有进行过滤，我们来看一下漏洞文件 <strong>phpcms/modules/content/down.php</strong> 。在其 <strong>init</strong> 方法中，从 <strong>GET</strong> 数据中获取了 <strong>a_k</strong> 的值，该值若能解密成程序规定格式的字符串，则程序继续运行（这里加解密使用的秘钥必须一致，例如这里秘钥为 <strong>pc_base::load_config(‘system’,’auth_key’)</strong> ）。程序将解密后的数据用 <strong>parse_str</strong> 函数处理，这里又存在变量覆盖问题。然后将可控变量 <strong>$id</strong> 带入数据库查询，我们跟进 <strong>get_one</strong> 方法。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/8.png" alt="8"></p>
<p> <strong>get_one</strong> 方法调用了 <strong>sqls</strong> 方法，而在 <strong>sqls</strong> 方法中可以明显看到，未过滤的数据直接拼接进了 <strong>SQL</strong> 语句中。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/9.png" alt="9"></p>
<p>那么现在，我们要解决的问题是：如何构造出加密数据，使得数据能够被正常解密？我们先来看一下 <strong>sys_auth</strong> 函数的代码，其代码位于 <strong>phpcms/libs/functions/global.func.php</strong> 中。开头我们可以很明显看到，当我们没有指定加解密用的 <strong>key</strong> 时，系统默认使用 <strong>pc_base::load_config(‘system’,’auth_key’)</strong> 作为 <strong>key</strong> ，这样我们就不用特地去搜索形如 <strong>sys_auth(‘xxx’,’ENCODE’,pc_base::load_config(‘system’,’auth_key’))</strong> 的代码段，直接搜索形如 <strong>sys_auth(‘可控字符串’,’ENCODE’)</strong> 或 <strong>sys_auth(‘可控字符串’)</strong> 的代码段即可。（这里搜索这种代码段的目的，是为了找到可利用的点将恶意 <strong>payload</strong> 进行加密，然后传输给开头 <strong>phpcms/modules/content/down.php</strong> 文件的 <strong>init</strong> 方法进一步利用）</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/10.png" alt="10"></p>
<p>通过搜索，会发现在 <strong>set_cookie</strong> 方法中使用了 <strong>sys_auth($value, ‘ENCODE’)</strong> ，我们可以寻找是否存在可控的 <strong>$value</strong> 。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/11.png" alt="11"></p>
<p>我们可以搜到 <strong>phpcms/modules/wap/index.php</strong> 文件，在该文件中 <strong>$_GET[‘siteid’]</strong> 可控，并且可以通过 <strong>cookie</strong> 获得加密后的数据，但是这里有 <strong>intval</strong> 过滤，所以无法放置我们的 <strong>payload</strong> 。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/12.png" alt="12"></p>
<p>我们继续寻找，会发现 <strong>phpcms/modules/attachment/attachments.php</strong> 文件的 <strong>swfupload_json</strong> 方法有满足我们需要的代码。程序将可控数据放在了 <strong>cookie</strong> ，其中可控数据中，比较好利用的是 <strong>$_GET[‘src’]</strong> 。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/13.png" alt="13"></p>
<p> <strong>$_GET[‘src’]</strong> 只是经过了 <strong>safe_replace</strong> 函数的过滤，该函数会将某些字符替换为空，而我们却可以在 <strong>payload</strong> 中插入这些字符，从而绕过黑名单的过滤。 <strong>safe_replace</strong> 函数代码如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/14.png" alt="14"></p>
<p>貌似现在已经找到了利用链了？别高兴的太早。在调用这个 <strong>swfupload_json</strong> 方法之前，程序会执行 <strong>attachments</strong> 类的 <strong>__construct</strong> 方法，而这个方法中有用户登录状态检测。用于登录状态检测的 <strong>$this-&gt;userid</strong> 可以来自 <strong>sys_auth($_POST[‘userid_flash’],’DECODE’)</strong> ，即我们让 <strong>$_POST[‘userid_flash’]</strong> 经过 <strong>sys_auth</strong> 方法解密之后有东西即可。而这个加密数据，就可以利用我们上面说到的 <strong>phpcms/modules/wap/index.php</strong> 文件。通过 <strong>cookie</strong> 获取 <strong>$_GET[‘siteid’]</strong> 加密后的数据，然后再作为 <strong>$_POST[‘userid_flash’]</strong> 的值，即可绕过登录检测。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/15.png" alt="15"></p>
<p>绕过登录检测后，我们将 <strong>payload</strong> 传给 <strong>phpcms/modules/attachment/attachments.php</strong> 文件 <strong>swfupload_json</strong> 方法中的 <strong>$_GET[‘src’]</strong> ，再利用开头 <strong>parse_str</strong> 函数进行变量覆盖，最终完成整个漏洞链。整个漏洞的利用流程图如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/16.png" alt="16"></p>
<p>按照默认配置安装的网站搭建好后， <strong>WAP</strong> 是处于禁用状态，但是这并不影响我们获得加密后的 <strong>$_GET[‘siteid’]</strong> 。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/17.png" alt="17"></p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/18.png" alt="18"></p>
<p>我们再来假设，如果网站管理员删除了 <strong>WAP</strong> 模块的代码，这个洞还能利用吗？我们可以继续来挖掘一下这个漏洞链的其他入口，这也是网络上未公开的一个入口点。上面我们在搜索 <strong>set_cookie</strong> 方法找可控数据时，会发现 <strong>phpcms/modules/mood/index.php</strong> 文件的 <strong>post</strong> 方法可以直接获得一个加密后的数据，这样我们就可以将这个数据，用在漏洞链的第二步：绕过用户登录验证，具体代码如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/19.png" alt="19"></p>
<p>这里只要按照代码逻辑，构造参数即可。这里可能还要注意本类的 <strong>__construct</strong> 方法，同样按照逻辑构造参数即可，具体构造这里不再赘述。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/20.png" alt="20"></p>
<p>通过上面这个漏洞链入口，我们便可以进行 <strong>报错SQL注入</strong> 。比较有意思的是， <strong>PHPCMS</strong> 会将 <strong>admin</strong> 登录的 <strong>cookie</strong> 存储在数据库中，我们可以通过注入获取管理员 <strong>cookie</strong> ，然后伪造管理员身份利用后台 <strong>getshell</strong> 。这里如何伪造身份，网络上貌似提及很少，唯一找到一篇文章<a href="https://www.secpulse.com/archives/57486.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/57486.html</a> ，发现作者竟然还少提及了一个关键参数。于是我将伪造的数据包，与正常登录的数据包进行对比，逐个删除 <strong>cookie</strong> 中的数据，看看少了哪个关键参数。接下来，我们来具体看一下如何伪造 <strong>cookie</strong> 进入后台。</p>
<p> <strong>PHPCMS</strong> 专门在数据库中建了一个表来存放 <strong>PHPSESSID</strong> ，其中也包含管理员的 <strong>PHPSESSID</strong> ，且登录状态下的 <strong>userid</strong> 字段会被设为1，注销则为0，具体如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/21.png" alt="21"></p>
<p>我们把 <strong>PHPSESSID=9t9mrk25ak5sb9v60nc255ql11</strong> 加到 <strong>cookie</strong> 中，直接访问后台，这是发现程序还是会让你登录，估计我们是少了什么，下面来动态调试一下。经过调试，我们会发现程序终止在了 <strong>admin</strong> 类 <strong>__construct</strong> 方法的 <strong>self::check_admin()</strong> 语句中，其具体代码如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/22.png" alt="22"></p>
<p>可以明显看到，我们原先的 <strong>cookie</strong> 中少了 <strong>$userid</strong> 对应的字段，而且要想绕过登录，必须保证 <strong>$_SESSION[‘roleid’]</strong> 和  <strong>$userid</strong> 相等且它们两者非空。那么现在，我们只要加上 <strong>$userid</strong> 对应字段就行了，其值可以从上面漏洞链第一步中的响应包 <strong>Set-Cookie</strong> 字段获取。这里要注意一个点，一旦管理员注销，我们就无法利用这个点伪造 <strong>cookie</strong> 了，这也是这个漏洞的鸡肋之处。</p>
<p>最后来看一下官方发布的 <strong>PHPCMS v9.6.1</strong> 中是如何修复这个漏洞的，补丁如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/23.png" alt="23"></p>
<p>可以看到官方对解密后的数据进行了 <strong>safe_replace、intval</strong> 双重过滤处理。</p>
<h2 id="v9-6-1任意文件读取"><a href="#v9-6-1任意文件读取" class="headerlink" title="v9.6.1任意文件读取"></a>v9.6.1任意文件读取</h2><p>这个版本的 <strong>任意文件读取</strong> 漏洞和上个版本的 <strong>SQL注入</strong> 漏洞原理是类似的，且出问题的文件均在 <strong>phpcms/modules/content/down.php</strong> 中。在该文件的 <strong>download</strong> 方法中最后一行调用了 <strong>file_down</strong> 文件下载函数，我们可以看到其第一个参数是要读取的文件路径。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/24.png" alt="24"></p>
<p>我们再来看看 <strong>download</strong> 方法中有哪些限制条件。可以看到其开头部分的代码，和上一个版本的 <strong>SQL注入</strong> 类似，唯一不同的是这里加解密的 <strong>key</strong> 变成了 <strong>$pc_auth_key</strong> ，我们等下就要来找找使用 <strong>$pc_auth_key</strong> 进行加密的可控点。继续看 <strong>download</strong> 方法，里面对要下载的文件后缀进行了黑名单校验，但是末尾又对 <strong>&gt;&lt;</strong> 字符进行替换，这就导致后缀名正则可被绕过，例如： <strong>.ph&lt;p</strong> 。(下图对应文件位置：phpcms/modules/content/down.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/25.png" alt="25"></p>
<p>现在我们就要来找找使用 <strong>$pc_auth_key</strong> 作为加密 <strong>key</strong> 的可控点。通过搜索关键字，我们可以看到有三处地方。然而前两处地方是不可以利用的，因为都有登录检测。而第三个点就可以利用，我们看其中 <strong>$i、$d、$s</strong> 作为明文字符串被加密。(下图对应文件位置：phpcms/modules/content/down.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/26.png" alt="26"></p>
<p>有了加密字符串，我们如何能够从前台获取呢，这里其实在最后一行包含模板文件时，将加密字符串 <strong>$downurl</strong> 输出了，这样也就解决了我们获取的问题。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/27.png" alt="27"></p>
<p>那 <strong>$i、$d、$s</strong> 这三个变量从哪里来？我们往前看，代码有没有相当熟悉？这里只对 <strong>$i</strong> 进行了 <strong>intval</strong> 过滤，其他两个变量还是可以利用。而且加密字符串 <strong>$a_k</strong> 的获取，就和上个版本的 <strong>SQL注入</strong> 漏洞攻击链的前2步是一样的，这里不再赘述。(下图对应文件位置：phpcms/modules/content/down.php)</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/28.png" alt="28"></p>
<p>我们在构造 <strong>payload</strong> 的时候，我们要注意整个攻击过程会经过两次 <strong>safe_replace</strong> 、两次 <strong>parse_str</strong> 、一次 <strong>str_replace(array(‘&lt;’,’&gt;’), ‘’,$fileurl)</strong> ，而程序对 <strong>..</strong> 和 <strong>php</strong> 字符进行了检测。所以我们要想访问 <strong>php</strong> 文件或进行路径穿越，后缀可以设置成 <strong>ph&gt;p</strong> ，路径符可以变成 <strong>.&gt;.</strong> 。但是 <strong>safe_replace</strong> 函数会 <strong>str_replace(‘&gt;’,’&gt;’,$string)</strong> ，所以 <strong>&gt;</strong> 字符需要编码两次，变成 <strong>%25253e</strong> 。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/29.png" alt="29"></p>
<p>我们可以将整个漏洞的触发过程整理成下图：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/30.png" alt="30"></p>
<p>最后来看一下官方发布的 <strong>PHPCMS v9.6.2</strong> 中是如何修复这个漏洞的，补丁如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/31.png" alt="31"></p>
<p>可以看到补丁将后缀匹配规则放在离下载文件最近的地方，貌似能防止规则中的文件被读取，但是我们可以利用 <strong>windows</strong> 的特性，在 <strong>windows</strong> 下绕过这个正则，这也是网传的一种 <strong>PHPCMS v9.6.2任意文件下载</strong> 漏洞。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/32.png" alt="32"></p>
<h2 id="v9-6-2前台SQL注入"><a href="#v9-6-2前台SQL注入" class="headerlink" title="v9.6.2前台SQL注入"></a>v9.6.2前台SQL注入</h2><p>这个版本的的注入，是建立在任意文件读取漏洞存在的情况下才可利用。通过任意文件读取漏洞获得加解密的 <strong>key</strong> 值，我们可以用这个 <strong>key</strong> 加密我们的 <strong>SQL注入payload</strong> 。由于程序对解密后的数据并未过滤，最终导致漏洞发生。严格上来讲 <strong>v9.6.2</strong> 版本的注入只能在 <strong>windows</strong> 上利用，具体原因在上面的任意文件读取漏洞分析时也说了。下面我们来具体分析一下这个漏洞。</p>
<p>漏洞文件位于 <strong>phpcms/modules/member/classes/foreground.class.php</strong> ，代码如下图。我们可以明显看到下图第33行，程序直接将解密后的数据未经过滤直接带入查询。而待解密数据 <strong>$phpcms_auth</strong> 和解密秘钥 <strong>$auth_key</strong> 均可构造。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/33.png" alt="33"></p>
<p>我们先来看一下待解密数据 <strong>$phpcms_auth</strong> 如何构造。从下图中，可以看出程序将从 <strong>cookie</strong> 中的 <strong>xxx_auth</strong> 字段经过 <strong>sys_auth</strong> 函数解密后，返回给了 <strong>$phpcms_auth</strong> ，而默认情况下使用 <strong>pc_base::load_config(‘system’, ‘auth_key’)</strong> 作为加解密的 <strong>key</strong> 值。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/34.png" alt="34"></p>
<p>而 <strong>pc_base::load_config(‘system’, ‘auth_key’)</strong> 的值在网站搭建好后，会存储在 <strong>caches/configs/system.php</strong> 中，我们可以通过任意文件读取来获得这个值。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/35.png" alt="35"></p>
<p>现在 <strong>$phpcms_auth</strong> 已经搞定了，我们再来看看 <strong>$auth_key = get_auth_key(‘login’)</strong> 如何构造，跟进 <strong>get_auth_key</strong> 的代码。我们可以看到 <strong>$auth_key</strong> 由 <strong>$prefix、pc_base::load_config(‘system’,’auth_key’)、ip()</strong> 三个元素决定。前两个都是已知的，而第三个获取用户IP的函数存在IP伪造的问题，也可以是固定的。</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/36.png" alt="36"></p>
<p>所以 <strong>get_auth_key(‘login’)</strong> 的值也是我们可以构造的，剩下的事情只要我们将 <strong>payload</strong> 传给加密函数加密两次即可。我们最后再来看一下 <strong>PHPCMS v9.6.3</strong> 中是如何修复这个漏洞的，补丁如下：</p>
<p><img src="/img/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/37.png" alt="37"></p>
<p>可以明显看到，补丁将解密后获得的 <strong>$userid</strong> 进行了强转。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>分析历史漏洞好处在于，可以使自身对这个 <strong>CMS</strong> 更熟悉，摸清该 <strong>CMS</strong> 普遍存在的问题，甚至有机会通过 <strong>bypass</strong> 补丁来发现新的 <strong>0day</strong> 。有些补丁只是暂时修复了漏洞，安全隐患仍然存在。随着 <strong>CMS</strong> 功能越来越多，我们可以将新功能中的利用点，结合之前的风险点，打出一条漂亮的攻击链，期待下个 <strong>0day</strong> 的诞生。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Mochazz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://mochazz.github.io/2019/07/18/phpcms漏洞分析合集/">https://mochazz.github.io/2019/07/18/phpcms漏洞分析合集/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://mochazz.github.io">Mochazz's blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PHPCMS/">PHPCMS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/07/25/ThinkCMFX漏洞分析合集/"><i class="fa fa-chevron-left">  </i><span>ThinkCMFX漏洞分析合集</span></a></div><div class="next-post pull-right"><a href="/2019/07/04/metinfo6.2任意文件上传漏洞/"><span>Metinfo &lt;= 6.2.0前台任意文件上传漏洞(密文保护)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'cFxDjSziPHq4xGCbSpRGkND7-gzGzoHsz',
  appKey:'YhJIRxQHzY9Aix5pSGnYxKkv',
  placeholder:'ヾﾉ≧∀≦)o留下评论再走吧',
  avatar:'wavatar',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/backgroud.jpeg)"><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By Mochazz</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>